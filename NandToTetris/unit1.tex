\chapter{Boolean Functions and Gate Logic}

\section{Boolean Logic}

$x\ AND\ y \rightarrow x \land y$\\
$x\ OR\ y \rightarrow x \lor y$\\
$NOT(x) \rightarrow \neg x$\\

\subsection{Boolean Functions}

$f(x, y, z) = (x \land y) \lor (\neg x \land z)$

\begin{table}[h!]
    \begin{center} 
        \caption{$f(x, y, z)$}
        \label{tab:fxyz}
        \begin{tabular}{l|l|l|l}
            $x$ & $y$ & $z$ & $f$\\
            \hline
            0 & 0 & 0 & 0\\
            0 & 0 & 1 & 1\\
            0 & 1 & 0 & 0\\
            0 & 1 & 1 & 1\\
            1 & 0 & 0 & 0\\
            1 & 0 & 1 & 0\\
            1 & 1 & 0 & 1\\
            1 & 1 & 1 & 1\\
        \end{tabular}
    \end{center}
\end{table}

Both are identical representations

\subsection{Boolean Identies}

Commutative Laws:\\

$x \land y = y \land x$\\
$x \lor y = y \lor x$\\

Associative Laws:\\

$x \land (y \land z) = (x \land y) \land z$\\
$x \lor (y \lor z) = (x \lor y) \lor z$\\

Distributive Laws:\\

$x \land (y \lor z) = (x \land y) \lor (x \land z)$\\
$x \lor (y \land z) = (x \lor y) \land (x \lor z)$\\

De Morgan Laws:\\

$\neg(x \land y) = \neg(x) \lor \neg(y)$\\
$\neg(x \lor y) = \neg(x) \land \neg(y)$\\

\subsection{Boolean Functions Synthesis}

Given a Truth Table, how do we construct a boolean function for it?\\

Lets take an example, 

\begin{table}[h!]
    \begin{center} 
        \caption{Truth Table for a Boolean Function}
        \label{tab:example1}
        \begin{tabular}{l|l|l|l}
            $x$ & $y$ & $z$ & $f$\\
            \hline
            0 & 0 & 0 & 0\\
            0 & 0 & 1 & 1\\
            0 & 1 & 0 & 0\\
            0 & 1 & 1 & 0\\
            1 & 0 & 0 & 0\\
            1 & 0 & 1 & 0\\
            1 & 1 & 0 & 1\\
            1 & 1 & 1 & 0\\
        \end{tabular}
    \end{center}
\end{table}

This table can be represented by taking OR of the "true"" statements. 
We can represent the "true" statements by a boolean expression.
For example, $x = 0, y = 0, z = 1, f = 1$ can be represented by
$\neg x \land \neg y \land z$. This expression is only true when
$x = 0, y = 0, z = 1$ and false on all other cases. So, we can
represent every boolean function by AND of such terms.\\

The truth table \ref{tab:example1} can be represented by the expression:

$$
(\neg x \land \neg y \land z) \lor (x \land y \land \neg z)
$$

But what is the minimum size expression we can build from a truth
table? This is a NP-Complete problem and cannot be solved in
polynomial time if $P \neq NP$.\\

\subsection{Why NAND?}
We can represent every boolean expression only using NAND. This
can be trivially proved.

\section{Gate Logic}

A technique for implementing Boolean functions using logic gates.\\

Logic Gates:
\begin{enumerate}
    \item Elementary (Nand, And, Or, Not)
    \item Composite (Mux, Adder)
\end{enumerate}

\subsection{Elementary logic gates: Nand}

Gate Diagram: 

\begin{figure}[h!]
    \begin{center}
        \begin{circuitikz}
            \draw (0, 0) node[nand port] (mynand) {}
            (mynand.in 1) node[anchor=east] {a}
            (mynand.in 2) node[anchor=east] {b}
            (mynand.out) node[anchor=west] {out};
        \end{circuitikz}
        \caption{A Nand Gate}
    \end{center}
\end{figure}

Function Specification:

if (a == 1 and b == 1):
then out=0 else out=1

\newpage

\subsection{Elementary logic Gates: And, Or, Not}

\begin{figure}[h!]
    \begin{center}
        \begin{circuitikz}
            \draw (0, 0) node[and port] {};
        \end{circuitikz}
        \caption{A And Gate}
    \end{center}
\end{figure}

\begin{figure}[h!]
    \begin{center}
        \begin{circuitikz}
            \draw (0, 0) node[or port] {};
        \end{circuitikz}
        \caption{A Or Gate}
    \end{center}
\end{figure}

\begin{figure}[h!]
    \begin{center}
        \begin{circuitikz}
            \draw (0, 0) node[not port] {};
        \end{circuitikz}
        \caption{A Not Gate}
    \end{center}
\end{figure}

\subsection{Composite Gates}

A 3-Input And Gate is an example of a composite gate.
It can be build using two 2-Input And Gates.\\

Functional Specification:

if (a==1 and b==1 and c==1):
then out=1 else out=0

\section{Hardware Description Language}

Here is a possible implementation of a XOR gate in HDL.

\begin{lstlisting}
// Xor gate: out = (a And Not(b)) Or (Not(a) And b)

CHIP Xor {
    IN a, b;
    OUT out;

    PARTS:
    Not (in=a, out=nota);
    Not (int=b, out=notb);
    And (a=a, b=notb, out=aAndNotb);
    And (a=nota, b=b, out=notaAndb);
    Or (a=aAndNotb, b=notaAndb, out=out);
}
\end{lstlisting}

\subsection{Some comments on HDL}

\begin{itemize}
    \item HDL is a functional / declarative language
    \item The order of HDL statements is insignificant
    \item Before using a chip part, you must know its interface.
        For example: 
        \begin{lstlisting}
        Not(in= ,out= ), And(a=, b= ,out= )
        \end{lstlisting}
    \item Connections like
        \begin{lstlisting}
        partName(a=a,...) partName(..., out=out)
        \end{lstlisting}
        are common
\end{itemize}

Common HDLs:

\begin{itemize}
    \item VHDL
    \item Verilog
    \item Many more HDLs
\end{itemize}

Out HDL:

\begin{itemize}
    \item Similar in spirit to other HDLs
    \item Minimal and simple
    \item Provides all you need for this course
\end{itemize}

\section{Multi-Bit Buses}

Sometimes we manipulate "together" an array of bits.
It is conceptually convenient to think about such a group of bits
as a single entity, sometimes termed "bus".
HDLs will usually provide some convenient notion for handling
these buses.

\subsection{Examples on buses in HDL}

Here is and example of how buses work in HDL:

\begin{lstlisting}
/*
* Adds three 16-bit values
*/

CHIP Add3Way16 {
    IN first[16], second[16], third[16];
    OUT out[16];

    PARTS:

    Add16(a=first, b=second, out=temp);
    Add16(a=temp, b=third, out=out);
}
\end{lstlisting}

Another example:

\begin{lstlisting}
/*
*  ANDs together all 4 bits of the input
*/

CHIP And4Way {
    IN a[4];
    OUT out;

    PARTS:
    AND(a=a[0], b=a[1], out=t01)
    AND(a=t01, b=a[2], out=t012);
    AND(a=t012, b=a[3], out=out);
}
\end{lstlisting}

An example with output as a bus:

\begin{lstlisting}
/*
* Computes a bit-wise and of its two 4-bit
* input buses
*/

CHIP And4 {
    IN a[4], b[4];
    OUT out[4];

    PARTS:
    AND(a=a[0], b=b[0], out=out[0]);
    AND(a=a[1], b=b[1], out=out[1]);
    AND(a=a[2], b=b[2], out=out[2]);
    AND(a=a[3], b=b[3], out=out[3]);
}
\end{lstlisting}

\subsection{Sub-buses}

Buses can be composed from (and broken into) sub-buses:

\begin{lstlisting}
...
IN lsb[8], msb[8], ...
...
Add16(a[0..7]=lsb, a[8..15]=msb, b=..., out=...);
Add16(..., out[0..3]=t1m out[4..15]=t2);
\end{lstlisting}

Some syntactic choices of our HDL:

\begin{itemize}
    \item Overlaps of sub-buses are allowed on output buses of parts
    \item Width of internal pins is deduced automatically
    \item "false" and "true" may be used as buses of any width
\end{itemize}
